#include "libAanvaller.nxc"

void MordorControl()
{
    static drivestate lastdrivestate;
    static unsigned long tlastdrivestate;
    if(tlastdrivestate == 0)
    {
        lastdrivestate = currentdrivestate; //I think this works.. Thx NXC for auto struct assignment!
        tlastdrivestate = CurrentTick();
    }
    else if(CurrentTick() - tlastdrivestate < 2000)     //Calib
    {
        tlastdrivestate = CurrentTick();
    }
    else tlastdrivestate = 0;
    switch(lastdrivestate)          //Be careful, may be new
    {
        case PROPORTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case LINEAR:
            LinearDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case ROTATIONAL:
            RotationalDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case DIRECTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case COMPASS:
            CompassDrive(currentdrivestate.dir + 180, currentdrivestate.dirvel, 0, 100);
            break;
    }
    //Wait(300);  //Calib
    while(lightval < WHITEGREEN) UpdateSensorValues();
    while(lightval > WHITEGREEN) UpdateSensorValues();
    Wait(50);   //(H2PO4)-/(HPO4)2- //Calib
    
}

void Search()
{
    RotationalDrive(0, 0, 40 * sign(balldir)); //Calib
}

void Follow()
{
    if(balldir == 0) LinearDrive(0, 100, 0);
    switch(abs(balldir))
    {
        case 1:
            LinearDrive(0, 100, 10 * sign(balldir));  //Calib
            break;
        case 2:
            LinearDrive(100 * sign(balldir), 0, 40 * sign(balldir));  //Calib
            //DirectionalDrive(45 * sign(dir), 100, 20 * sign(dir)); //In geval van goede sensor //Calib
            break;
        case 3:
            DirectionalDrive(0, 0, 100 * sign(balldir));  //Calib (goed rondje)
            
            break;
        case 4:
            DirectionalDrive(0, 0, 100 * sign(balldir));  //Calib (goed rondje)
            break;
    }
}

void Align()
{

}

void Target()       //Vrot = Vx/r (Vrot is rotating speed, Vx is snelheid x-richting, r is de straal van de cirkel die de robot maakt)
{
    if(abs(orient) < 20)
    {
        if(orient < 0) LinearDrive(0, 100, -10)
        if(orient > 0) LinearDrive(0, 100,  10)
        Wait(50); //Calib
        if(CurrentTick() - tlastkick >= RECHARGINGTIME)
        {
            Kick();
        }
    }
    else;
    //Hier wiskunde / kalibratie
    // Waardes keer sign(orient) of iets proportioneels (draaing om bal heen)
}

task main()
{
    Init();
    while(true)
    {
        UpdateSensorValues();
        if(lightval > WHITEGREEN)
        {
            TextOut(0, LCD_LINE7, "MordorControl");
            MordorControl();
        }
        else switch(ballstate)
        {
            case POSSESSION:
                TextOut(0, LCD_LINE7, "Target");
                Target();
                break;
            case CLOSE:
                TextOut(0, LCD_LINE7, "Align");
                Align();
                break;
            case FAR:
                TextOut(0, LCD_LINE7, "Follow");
                Follow();
                break;
            case LOST:
                TextOut(0, LCD_LINE7, "Search");
                Search();
                break;
        }
    }
}
