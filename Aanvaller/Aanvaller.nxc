#include "libAanvaller.nxc"

void MordorControl()
{
    static drivestate lastdrivestate;
    static unsigned long tlastdrivestate;
    if(tlastdrivestate == 0)
    {
        lastdrivestate = currentdrivestate; //I think this works.. Thx NXC for auto struct assignment!
        tlastdrivestate = CurrentTick();
    }
    else if(CurrentTick() - tlastdrivestate < 2000)     //Calib
    {
        tlastdrivestate = CurrentTick();
    }
    else tlastdrivestate = 0;
    switch(lastdrivestate)          //Be careful, may be new
    {
        case PROPORTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case LINEAR:
            LinearDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case ROTATIONAL:
            RotationalDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case DIRECTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case COMPASS:
            CompassDrive(currentdrivestate.dir + 180, currentdrivestate.dirvel, 0, 100);
            break;
    }
    //Wait(300);  //Calib
    while(lightval < WHITEGREEN) UpdateSensorValues();
    while(lightval > WHITEGREEN) UpdateSensorValues();
    Wait(50);   //(H2PO4)-/(HPO4)2- //Calib
    
}

void Search()
{
    RotationalDrive(0, 0, 40 * sign(balldir)); //Calib
}

void Follow()
{
    if(balldir == 0) LinearDrive(0, 100, 0);
    switch(abs(balldir))
    {
        case 1:
            LinearDrive(0, 100, -10 * sign(balldir));  //Calib
            break;
        case 2:
            LinearDrive(100 * sign(balldir), 0, 40 * sign(balldir));  //Calib
            //DirectionalDrive(45 * sign(dir), 100, 20 * sign(dir)); //In geval van goede sensor //Calib
            break;
        case 3:
            DirectionalDrive(0, 0, -100 * sign(balldir));  //Calib (goed rondje)
            
            break;
        case 4:
            DirectionalDrive(0, 0, -100 * sign(balldir));  //Calib (goed rondje)
            break;
    }
}

void Align()
{
    switch(balldir)
    {
        case 1:
            if(orient < -20) DirectionalDrive(-135, 100,  30, 100);
            if(orient >  20) DirectionalDrive(-135, 100, -30, 100);
            else             CompassDrive(135, 100, 0, 100);
            break;
        case 2:
            if(orient < -20) DirectionalDrive(-135, 100, 30, 100);
            if(orient >  20) DirectionalDrive(-135, 100, -30, 100);
            else CompassDrive(135, 100, 0, 100);
            break;
        case 3:
            if(orient < -20) DirectionalDrive(135, 100, 30, 100);
            if(orient >  20) DirectionalDrive(135, 100, -30, 100);
            else CompassDrive(180, 100, 0, 100);
            break;
        case 4:
            if(orient < -20) DirectionalDrive(45, 100, 30, 100);
            if(orient >  20) DirectionalDrive(45, 100, -30, 100);
            else CompassDrive(90, 100, 0, 100);
            break;
        case 5:
            if(orient < -20) DirectionalDrive(0, 100, 30, 100);
            if(orient >  20) DirectionalDrive(0, 100, -30, 100);
            else CompassDrive(0, 100, 0, 100);
            break;
        case 6:
            if(orient < -20) DirectionalDrive(-45, 100, 30, 100);
            if(orient >  20) DirectionalDrive(-45, 100, -30, 100);
            else CompassDrive(-45, 100, 0, 100);
            break;
        case 7:
            if(orient < -20) DirectionalDrive(-135, 100, 30, 100);
            if(orient >  20) DirectionalDrive(-135, 100, -30, 100);
            else CompassDrive(-135, 100, 30, 100);
            break;
        case 8:
            if(orient < -20) DirectionalDrive(135, 100, 30, 100);
            if(orient >  20) DirectionalDrive(135, 100, -30, 100);
            else CompassDrive(135, 100, 0, 100);
            break;
        case 9:
            if(orient < -20) DirectionalDrive(135, 100, 30, 100);
            if(orient >  20) DirectionalDrive(135, 100, -30, 100);
            else CompassDrive(135, 100, 0, 100);
    }
}

void Target()       //Vrot = Vx/r (Vrot is rotating speed, Vx is snelheid x-richting, r is de straal van de cirkel die de robot maakt)
{
    int r;
    int Vrot;
    if(abs(orient) < 20)
    {
        if(orient < 0) LinearDrive(0, 100, -10);
        if(orient > 0) LinearDrive(0, 100,  10);
        Wait(50); //Calib
        if(CurrentTick() - tlastkick >= RECHARGINGTIME) Kick();
    }
    else
    {
        
        Vrot = 50;           //Calib
        r = 11.6;           //Calib
        ProportionalDrive(Vrot/r  * sign(balldir), 0, Vrot * sign(balldir), 100);
    }
}

//#define CHECKLINE

task main()
{
    Init();
    while(true)
    {
        UpdateSensorValues();
        #ifdef CHECKLINE
        if(lightval > WHITEGREEN)
        {
            TextOut(0, LCD_LINE7, "MordorControl");
            MordorControl();
        }
        else
        #endif
        switch(ballstate)
        {
            case POSSESSION:
                TextOut(0, LCD_LINE8, "Target");
                Target();
                break;
            case CLOSE:
                TextOut(0, LCD_LINE8, "Align");
                Align();
                break;
            case FAR:
                TextOut(0, LCD_LINE8, "Follow");
                Follow();
                break;
            case LOST:
                TextOut(0, LCD_LINE8, "Search");
                Search();
                break;
        }
    }
}
