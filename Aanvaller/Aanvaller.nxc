#include "libAanvaller.nxc"

void MordorControl()
{
    static drivestate lastdrivestate;
    static unsigned long tlastdrivestate;
    if(tlastdrivestate == 0)
    {
        lastdrivestate = currentdrivestate;
        tlastdrivestate = CurrentTick();
    }
    else if(CurrentTick() - tlastdrivestate < 2000)     //Calib
    {
        tlastdrivestate = CurrentTick();
    }
    else tlastdrivestate = 0;
    switch(lastdrivestate)          //Be careful, may be new
    {
        case PROPORTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case LINEAR:
            LinearDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case ROTATIONAL:
            RotationalDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case DIRECTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case COMPASS:
            CompassDrive(currentdrivestate.dir + 180, currentdrivestate.dirvel, 0, 100);
            break;
    }
    //Wait(300);  //Calib
    while(lightval < WHITEGREEN) UpdateSensorValues();
    while(lightval > WHITEGREEN) UpdateSensorValues();
    Wait(50);   //(H2PO4)-/(HPO4)2- //Calib
    
}

void Search()
{
    RotationalDrive(0, 0, 40 * sign(dir)); //Calib
}

void Follow()
{
    if(dir == 0) LinearDrive(0, 100, 0);
    switch(abs(dir))
    {
        case 1:
            LinearDrive(0, 100, 10 * sign(dir));  //Calib
            break;
        case 2:
            LinearDrive(100 * sign(dir),0,40 * sign(dir));  //Calib
            //DirectionalDrive(45 * sign(dir), 100, 20 * sign(dir)); //In geval van goede sensor //Calib
            break;
        case 3:
            DirectionalDrive(0, 0, 100 * sign(dir));  //Calib (goed rondje)
            
            break;
        case 4:
            DirectionalDrive(0, 0, 100 * sign(dir));  //Calib (goed rondje)
            break;
    }
}

void Align()
{
    int t0, t1;
    t0 = CurrentTick();
    while(ballstate == CLOSE && lightval < WHITE)   //ballsaté
    {
        UpdateSensorValues();
        if(balldir == 5)
        {
            LinearDrive(0,80,0);
            t1 = CurrentTick();
        }
        if(balldir < 5 && t1-t0 < 200) DirectionalDrive(315, 80, 0, 100);
        if(balldir < 5 && t1-t0 > 200) LinearDrive(100, 0, 0);
        if(balldir > 5 && t1-t0 < 200) DirectionalDrive(45, 80, 0, -100);
        if(balldir > 5 && t1-t0 < 200) LinearDrive(-100, 0, 0);
    }
}

void Target()
{
    if(orient <= 20 && orient >= -20 && possession)
    {
        LinearDrive(0,100,0);
        if(CurrentTick() - tlastkick > RECHARGINGTIME)
        {
            Kick();
        }
    }
    else;
    //Hier wiskunde / kalibratie
    // Waardes keer (orient >> 15) of iets proportioneels
}

task main()
{
    Init();
    while(true)
    {
        UpdateSensorValues();
        if(lightval > WHITEGREEN)
        {
            TextOut(0, LCD_LINE7, "MordorControl");
            MordorControl();
        }
        else switch(BALLSTATE)
        {
            case POSSESION:
                TextOut(0, LCD_LINE7, "Target");
                Target();
                break;
            case CLOSE:
                TextOut(0, LCD_LINE7, "Align");
                Align();
                break;
            case FAR:
                TextOut(0, LCD_LINE7, "Follow");
                Follow();
                break;
            case LOST:
                TextOut(0, LCD_LINE7, "Search");
                Search();
                break;
        }
    }
}
