#include "libAanvaller.nxc"

/*
void MordorControl()
{
    switch(currentdrivestate.type)          //Be careful, may be new
    {
        case PROPORTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case LINEAR:
            LinearDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case ROTATIONAL:
            RotationalDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case DIRECTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case COMPASS:
            CompassDrive(currentdrivestate.dir + 180, currentdrivestate.dirvel, 0, 100);
            break;
    }
    Wait(2000);
}
*/

void MordorControl()
{
    static drivestate lastdrivestate;
    static unsigned long tlastdrivestate;
    if(tlastdrivestate == 0)
    {
        lastdrivestate = currentdrivestate; //I think this works.. Thx NXC for auto struct assignment!
        tlastdrivestate = CurrentTick();
    }
    else if(CurrentTick() - tlastdrivestate < 2000)     //Calib
    {
        tlastdrivestate = CurrentTick();
    }
    else tlastdrivestate = 0;
    switch(lastdrivestate)          //Be careful, may be new
    {
        case PROPORTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case LINEAR:
            LinearDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case ROTATIONAL:
            RotationalDrive(-currentdrivestate.x, -currentdrivestate.y, 0);
            break;
        case DIRECTIONAL:
            ProportionalDrive(-currentdrivestate.x, -currentdrivestate.y, 0, 100);
            break;
        case COMPASS:
            CompassDrive(currentdrivestate.dir + 180, currentdrivestate.dirvel, 0, 100);
            break;
    }
    //Wait(300);  //Calib
    while(lightval < WHITEGREEN) UpdateSensorValues();
    while(lightval > WHITEGREEN) UpdateSensorValues();
    Wait(100);   //(H2PO4)-/(HPO4)2- //Calib
}

void Search()
{
    RotationalDrive(0, 0, 40 * sign(balldir)); //Calib
}

void Follow()
{
    if(balldir == 0) LinearDrive(0, 100, 0);
    else if(currentballstate == FAR)
    {
        switch(abs(balldir))
        {
            case 1:
                LinearDrive(0, 100, 10 * sign(balldir));  //Calib
                break;
            case 2:
                LinearDrive(100 * sign(balldir), 0, 40 * sign(balldir));  //Calib
                //DirectionalDrive(45 * sign(dir), 100, 20 * sign(dir)); //In geval van goede sensor //Calib
                break;
            case 3:
                DirectionalDrive(0, 0, 100 * sign(balldir));  //Calib (goed rondje)

                break;
            case 4:
                DirectionalDrive(0, 0, 100 * sign(balldir));  //Calib (goed rondje)
                break;
        }
    }
    else
    {
        if(balldir == 0) LinearDrive(0, 50, 0);
        switch(abs(balldir))
        {
            case 1:
                LinearDrive(10 * sign(balldir), 75, 20 * sign(balldir));  //Calib
                break;
            case 2:
                LinearDrive(75 * sign(balldir), 0, 40 * sign(balldir));  //Calib
                //DirectionalDrive(45 * sign(dir), 100, 20 * sign(dir)); //In geval van goede sensor //Calib
                break;
            case 3:
                DirectionalDrive(0, 0, 50 * sign(balldir), 100);  //Calib (goed rondje)

                break;
            case 4:
                DirectionalDrive(0, 0, 50 * sign(balldir), 100);  //Calib (goed rondje)
                break;
        }
    }
}

void Align()
{
    int corrspeed = -orient / 2;
    if(corrspeed > 30) corrspeed = 30;
    if(corrspeed < -30) corrspeed = -30;
    switch(abs(balldir))
    {
        case 4:
            DirectionalDrive(-90 * sign(balldir),  75, corrspeed, 100);
            break;
        case 3:
            DirectionalDrive(-150 * sign(balldir), 100, corrspeed, 100);
            break;
        case 2:
            DirectionalDrive(150 * sign(balldir), 75, corrspeed, 100);
            break;
        case 1:
            DirectionalDrive(75 * sign(balldir), 100, corrspeed, 100);
            break;
        case 0:
            DirectionalDrive(0, 100, corrspeed, 100);
            break;
    }

}

void Target()       //Vrot = Vx/r (Vrot is rotating speed, Vx is snelheid x-richting, r is de straal van de cirkel die de robot maakt)
{
    Off(OUT_ABC);
    LinearDrive(0,-100,0);
    Wait(50);
    int r;
    int Vrot;
    if(abs(orient) < 13)
    {
        if(orient < 0) LinearDrive(0, 100, -10);
        if(orient > 0) LinearDrive(0, 100,  10);
        Wait(50); //Calib
        if(CurrentTick() - tlastkick >= RECHARGINGTIME) Kick();
    }
    else
    {
        
        Vrot = 50;           //Calib
        r = 11.6;           //Calib
        ProportionalDrive(80 * sign(orient), 30, -40 * sign(orient), 100);
    }
}

void DistCheck()
{
    switch(balldir)
    {
        case -4:
            RotationalDrive(0, 0, -100);   //Calib
            break;
        case -3:
            RotationalDrive(0, 0, -80);
            break;
        case -2:
            RotationalDrive(0, 0, -60);
            break;
        case -1:
            RotationalDrive(0, 0, -30);
            break;
        case 0:
            Follow();
            break;
        case 1:
            RotationalDrive(0, 0, 30);
            break;
        case 2:
            RotationalDrive(0, 0, 60);
            break;
        case 3:
            RotationalDrive(0, 0, 80);
            break;
        case 4:
            RotationalDrive(0, 0, 100);
            break;
    }
}

#define CHECKLINE
#ifndef FUNCTIONTEST

task main()
{
    LinearDrive(0,100,0);
    Init();
    Wait(500);
    while(true)
    {
        UpdateSensorValues();
        #ifdef CHECKLINE
        if(lightval > WHITEGREEN)
        {
            TextOut(0, LCD_LINE7, "MordorControl");
            MordorControl();
        }
        else
        #endif
        switch(currentballstate)
        {
            case POSSESSION:
                TextOut(0, LCD_LINE8, "Target");
                Target();
                break;
            case CLOSE:
                TextOut(0, LCD_LINE8, "Align");
                Align();
                break;
            case FAR:
                TextOut(0, LCD_LINE8, "Follow");
                Follow();
                break;
            case LOST:
                TextOut(0, LCD_LINE8, "Search");
                Search();
                break;
        }
    }
}

#endif
